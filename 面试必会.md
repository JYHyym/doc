<!--
 * @Author: haopeiwei
 * @Date: 2019-08-12 14:31:25
 * @LastEditors: haopeiwei
 * @LastEditTime: 2019-08-13 10:30:53
 -->
 ## 实现new操作符
 ---

 ```js
function myNew(fn, ...args) {
    if (typeof fn !== 'function') {
        throw new Error('the firest parameter expectation is a function')
    }
    // 原型继承
    let newObj = Obj.create(fn.prototype);
    // 改变this指向
    // 获取fn返回的返回的结果，如果在fn里没有返回Object类型（包括Date.Funciton
    // .Array.Error.RegExp）则会直接返回这些值。否则返回新的对象，即newObj
    let res = fn.apply(newObj, args);
    if ((typeof res === 'object' || typeof res === 'function') && res !== null) {
        return res
    }
    return newObj;
}
 ```

 ## 防抖函数
 ---

  - 连续触发事件函数，只会执行一次，且要两次触发事件函数的时间间隔要满足delay

 ```js

function debounce(fn, delay) {
  let timer = null;
  return function() {
    let that = this;
    let args = arguments;
    cleartTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(that,agrs);
    }, delay);
  }
}

 ```

 ## 节流函数
---

- 触发事件函数后，短时间间隔内无法连续调用，只有上一次函数执行后，过了规定的时间间隔，才能进行下一次函数的调用。

```js

function throttle(fn, delay, wait) {
    let timer = null,
    start = 0, now = 0;
    return function() {
        const that = this;
        const args = arguments;
        now = Date.now();
        if (!start) {
            start = now;
        }
        // 满足间隔则立即调用 首次
        if (now - start >= wait) {
            fn.apply(that, args);
            start = Date.now();
        } else {
        // 重置定时器  
            clearTimeout(timer);
            timer = setTimeout(function() {
                fn.apply(that, args);
            }, delay);
        }
    }
}
```