## 定义

  能够访问另一个函数作用域的变量的函数。 通俗来说，闭包就是一个函数，能够访问其他函数中作用域的变量。
  最常的应用访问内部函数的变量、变量私有化。

  - 一个列子
  ```js
  function A() {
    var name = "leo";
    return function () {
      alert(name);
    }
  }

  let a = A();
  a();

  ```
  作用域链回顾：


  某个函数被调用时，会创建一个执行环境及相应的的作用域链（**创建，并不是定义，函数能访问的活动变量在函数定义那一刻已经决定**）。然后，**使用arguments、this（自动获得，永远不可能会访问到外部函数的这两个变量）和其他命名参数来初始化函数的活动对象**。但在作用域中，外部函数的活动对象始终处于第二位，直到顶层，终点为全局执行环境。

  ```js

  var name = "leo";
  function getName() {
    console.log(name);
  }
  (function(){
    var name = "vayne";
    getName();  // leo
  })();

  ```

## 副作用

  ### 闭包与变量
  **闭包只能取得包含函数中任何变量的最后一个值。**

  ```js
  function A() {
    var res = new Array();
    for (var i = 0; i < 10; i++) {
      result[i] = function () {
        return i;
      };
      // 匿名函数中都保存了A的活动变量，for循环结束后变成了10,因此输出10个10
    }
    return result;
  }
  // 改进
    function A() {
    var res = new Array();
    for (var i = 0; i < 10; i++) {
      result[i] = function (num) {
        return function() {
          return num;
        }
      }(i);
      // 匿名函数中都保存了A的活动变量，for循环结束后变成了10,因此输出10个10
    }
    return result;
  }
  ```

  ### this对象

  this是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行通常指向window。（apply、call等指向其他其他对象）

  ```js
  var name = "the window";
  var object = {
    name: "my object",
    getNameFunc: function() {
      return function() {
        return this.name;
      }
    }
  }
  object.getNameFunc()();  // the window
  // 函数活动变量会自动获得arguments/this，不会再去搜索外部函数的this
  // 也可以理解为：
  // b = object.getNameFunc(); b(); b隐式绑定，自然挂载在window上，此时的this指向window，name访问the window


  var name = "the window";
  var object = {
    name: "my object",
    getNameFunc: function() {
      var that = this; // 将this赋值为that，保存变量。
      return function() {
        return that.name;
      }
    }
  }
   object.getNameFunc()();  //即使object.getNameFunc()挂载在window上，里面的匿名函数执行不是当前的this而是保存在活动对象的中的this,即that

  var name =  "the window";
  var object = {
    name: "my object",
    getName: function() {
      return this.name;
    }
  }

  (object.getName = object.getName)() // the window
  // 原因在于()里只是一个赋值表达式，将左边的函数赋予右边的函数值，此时的this已发生改变

  ```

  ### 内存泄漏

  ```js
  function handler() {
    var ele = document.getElementById("div");
    var id = ele.id;
    ele.onclick = function() {
      alert(id)
    };
  }
  ```

  创建了一个作为element元素事件处理程序的闭包。匿名函数保存了handler的活动对象的引用，
  只要匿名函数存在，**闭包会引用包含函数的整个活动对象**。ele的引用次数至少是1，它所占的内存就永远不会保存。

  ```js
  ele = null;
  ```
  将ele设置为null,解除对DOM对象的引用。

  ### 模仿块级作用域

  ES5是没有块级作用域的概念的。
  这意味着在块语句中定义的变量，实际是在包含函数中而非语句中创建的。

  ```js
  function outputNumber(count) {
    // i 作为函数的活动变量始终可以访问
    for (var i = 0; i < count; i++) {
      console.log("I :" + i); // 0 1 2 3 4
    }
    console.log(i); // 5
  }

  outputNumber(5);
  ```

  ```js
  function outputNumber(count) {
    (function() {
      for (var i = 0; i < count; i++) {
        console.log("I :" + i); // 0 1 2 3 4
      } 
    })();
    // 私有作用域，在匿名函数执行结束后，定义的任何变量偶读将销毁
    // 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。
   
    console.log(i); // Uncaught ReferenceError: i is not defined
  }

  outputNumber(5);
  ```

  ```js
  (function(){
    // 块级作用域
  })();
  ```

  ### 私有变量
  
  ### 模块模式