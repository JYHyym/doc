# 继承

## 构造函数、实例、原型

  每个构造函数里都有一个原型对象，每个原型对象都包含指向构造函数的指针，而每个实例都包含一个指向原型对象的内部指针。

## 原型和实例

  可以通过instanceof、isPrototypeOf判断。

  ```js
    instance instanceof Prototype

    Prototype.prototype.isPrototype(instance)
  ```


## 原型链继承

  ```js
    function F() {
      this.name = "leo"
    }
    F.prototype.getName = function () {
      return this.name;
    }
    function S() {
      this.sname = "cdd";
    }
    S.prototype = new F();
    let instance = new S();
    console.log("instance", instance);

  ```

  ### 注意
  
  - 子类需要覆盖超类中的某个方法，或者需要添加超类中不存在的方法。不管怎么样，**给原型添加方法的代码一定要放在替换原型的语句后。** **覆盖超类方法时，子类的实例将会执行最新的方法吗，而超类实例会执行超类的原方法。**

  ```js
    function F() {
      this.name = "A"
    }
    F.prototype.getName = function () {
      return this.name;
    }
    function S() {
      this.sname = "B";
    }
    S.prototype = new F();
    // 定义的子类方法在后面
    // 覆盖老方法
    S.prototype.getName = function () {
      return "C";
    };
    // 添加新方法
    S.prototype.addName = function () {
      this.name = "D";
    }
    let instance = new S();
    let fIns = new F();

    console.log(instance.getName()) // C
    console.log(fIns.getName()); // A
  ```

  - 另外，在通过原型链实现继承时，不能使用对象字面量的方法创建原型方法。这样做会重写原型链。

  ```js
    function F() {
      this.name = "A"
    }
    F.prototype.getName = function () {
      return this.name;
    }
    function S() {
      this.sname = "B";
    }
    S.prototype = new F();
    S.prototype = {  // 这样做会导致F和S切断联系，S.prototype已成为Object的实例
      someMethod: function () {
        console.log(this.name);
      }
    }
    let instance = new S();
    console.log(instance.getName()) // instance.getName is not a function
  ```

  ### 存在问题

  - 引用值类型时，当一个实例进行修改，所有该原型所创造的实例将会共享这个实例。

    ```js
      function F() {
          this.fruits = ["orange", "apple", "peach"];
        }
      function S() {

      }

      S.prototype = new F();

      let s1 = new S();
      s1.fruits.push("watermelon");

      let s2 = new S();
      
      console.log(s2.fruits); //  ["orange", "apple", "peach", "watermelon"]
    ```

  - 在创建子类型实例的时，不能向超类型的构造函数中传递参数


## 借用构造函数

  为了解决引用类型值所带来的的问题，名为借用构造函数的技术（伪造对象或经典继承）出现了。
  基本思想：**在子类构造函数的内部调用超类构造函数，通过apply或call方法在将来新创建的对象上
  执行构造函数。**

  ```js

    function F(name) {
      this.name = name;
    }
    F.prototype.getName = function () {
      return "B";
    };
    function S() {
      F.call(this, "leo");
    }
    let s = new S();
    console.log(s.name); // leo
    console.log(s.getName()); // 报错 方法不存在 访问不到
  ```

  修改代码如下：

  ```js
    function F(name) {
      this.name = name;
      // 新增
      this.getName = function () {
        return name;
      }
    }
    F.prototype.getName = function () {
      return "B";
    };
    function S() {
      F.call(this, "leo");
      // 新增
      this.color = function () {
        return "red";
      }
    }
    // 新增
    S.prototype.color = function () {
      return "green";
    };

    let s = new S();

    console.log(s.name); // leo
    console.log(s.color()); // red
    console.log(s.getName()); //leo

  ```
  由上可总结出构造函数继承的优缺点

  ### 优点

  - 解决函数传参问题
  - 解决引用类型值问题

  ### 缺点

  - 在超类型中原型中定义的方法对子类是不可见的，在子类原型中定义的方法同样获取不到
  - 方法和属性都只能写在构造函数中才可访问，函数复用无从谈起。只能在构造函数中添加。

