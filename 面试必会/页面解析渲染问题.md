


![示意图](https://github.com/death-hpw/my-images/blob/master/20191106142711.png)


 **DOM解析和CSS解析是两个并行的进程**，这也是为什么CSS加载不会影响DOM解析的原因。
 **RENDER TREE依赖于DOM TREE和 CSS RULE TREE**，因此，页面的渲染要等CSS RULE TREE（即使外部CSS依赖加载失败,也需等待）和DOM TREE解析完成, 从而CSS加载影响DOM的渲染。

## 渲染过程

  1.HTML解析文件，从上至下，顺序执行，生成DOM Tree，解析CSS文件生成CSS RULE Tree

  2.将Dom Tree和CSS DOM Tree结合，生成Render Tree(渲染树)

  3.根据Render Tree渲染绘制，将像素渲染到屏幕上。 RENDER TREE -> LAYOUT（布局） -> PAINT(绘制)

## CSS

  1.**CSS的加载不会影响DOM树的解析,但是会影响DOM树的渲染**

  2.**CSS的加载会影响在之后面的JS文件执行**

  3.CSS不会阻塞外部JS的加载，但会阻塞执行

## JS

  1.JS顺序执行

  2.JS会阻塞html的解析和渲染

  3.没有defer和async标签的script会立即加载并执行

　4.有async标签的js，js的加载执行和html的解析和渲染并行，下载完成后立即执行，不依赖CSS和HTML，**加载顺序不固定**

　5.有defer标签的js，js的加载和html的解析和渲染并行，但会在html解析完成后执行,**在触发DOMContentLoaded事件执行**


如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。



---


      
     在head中如果遇到script标签，会暂停html的解析，将网页的渲染权交给JS引擎。
     如果<script>标签引用了外部脚本，就下载该脚本，否则就直接执行。
     执行完毕，控制权再交给渲染引擎，恢复下载解析HTML网页


## 重绘
  
重绘（repaint）: 当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫重绘


## 回流

回流（reflow）: 当DOM数中一部分或者大部分因为元素的大小、布局、隐藏等改变而需要重新构建。

  - 减少reflow的方法：

      1. 尽可能限制reflow的影响范围，需要改变元素的样式。比如直接修改子元素，不要通过父元素
      2. 通过设置class去修改样式，减少通过style样式直接去修改
      3. 尽可能回流的范围，例如通过marginLeft去代替left




**回流必然会引起重绘，重绘不一定引起回流。**

##### 导致回流的操作：

    页面首次渲染
    浏览器窗口大小发生改变
    元素尺寸或位置发生改变
    元素内容变化（文字数量或图片大小等等）
    元素字体大小变化
    添加或者删除可见的DOM元素
    激活CSS伪类（例如：:hover）
    查询某些属性或调用某些方法


## 监听加载完成

  ```js
   window.DOMContentLoaded = function() { 
    alert("页面加载完成！"); 
  } 
  window.onload = function() { 
    alert("页面加载完成！"); 
  } 
  ```
  
## 优化建议

  1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)

  2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)

  3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)

  4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)